package main

import (
	"errors"
	"fmt"
	"github.com/spf13/cobra"
	"os"
	"path"
	"path/filepath"
	"sort"
	"strings"
)

// //////////////////////////////////////////////////////////////

var writeCppCmd = &cobra.Command{
	Use:   "write-cpp",
	Short: "C++ file generation",
	RunE: func(cmd *cobra.Command, args []string) error {
		if CmdFromFilePath == "" {
			return errors.New("you must specify a file using " + cyan("--fileFrom"))
		}

		pathFileRead := CheckFilePath(CmdFromFilePath)
		if pathFileRead != FilePathValid {
			return errors.New(cyan("--fileFrom") + ":\t" + pathFileRead.String())
		}

		CmdFromFilePath, err := filepath.Abs(CmdFromFilePath)
		if err != nil {
			return errors.New(cyan("--fileFrom") + ":\t" + err.Error())
		}

		//

		if CmdToFilePath == "" {
			return errors.New("you must specify a file using " + cyan("--fileTo"))
		}

		pathFileWrite := CheckFilePath(CmdToFilePath)
		if pathFileWrite != FilePathValid && pathFileWrite != FilePathIsDir && pathFileWrite != FilePathValidDir {
			return errors.New(cyan("--fileTo") + ":\t" + pathFileWrite.String())
		}

		CmdToFilePath, err := filepath.Abs(CmdToFilePath)
		if err != nil {
			return errors.New(cyan("--fileTo") + ":\t" + err.Error())
		}

		//

		if pathFileWrite == FilePathIsDir {
			CmdToFilePath = filepath.Join(CmdToFilePath, "addressbook.h")
		}

		//

		obj, err := ParseYml(CmdFromFilePath)
		if err != nil {
			return err
		}

		return writeCpp(obj, CmdToFilePath)
	},
}

// //

func writeCpp_FileBegin(fileName, pathToDir string) (*os.File, error) {
	file, err := os.Create(path.Join(pathToDir, fileName))
	if err != nil {
		return nil, err
	}

	fileName = strings.ToUpper(ToGoVariableName(fileName))

	_, err = file.WriteString("/**  This file is automatically generated  **/\n\n")
	if err != nil {
		return nil, err
	}
	file.WriteString(fmt.Sprintf("#ifndef %s_H\n#define %s_H\n\n", fileName, fileName))

	return file, nil
}

func writeCpp_delInDir(dir string) {
	entries, err := os.ReadDir(dir)
	if err != nil {
		return
	}

	for _, entry := range entries {
		if !entry.IsDir() {
			os.Remove(filepath.Join(dir, entry.Name()))
		}
	}
}

func writeCpp_FileEnd(file *os.File) {
	file.WriteString("\n#endif")
	file.Close()
}

func writeCpp_write(file *os.File, tab uint8, text string) {
	file.WriteString(strings.Repeat("\t", int(tab)))
	file.WriteString(text)
	file.WriteString("\n")
}

//

func writeCppMotherboards(mapMotherboards map[string]MotherboardObj, file *os.File) {
	write := func(tab uint8, text string) {
		writeCpp_write(file, tab, text)
	}

	// //

	nameStructEsp32Pinout := "Esp32PinoutObj"
	nameStructMotherboardI2C := "Esp32I2cObj"

	nameEsp32Pinout := "P"
	nameI2C := "I"

	write(1, fmt.Sprintf("struct %s{ unsigned char Pin; const char* Name; };", nameStructEsp32Pinout))
	write(1, fmt.Sprintf("struct %s{ const char* Chip; const char* Name; unsigned char Adr; };\n", nameStructMotherboardI2C))

	// //

	for _, key := range sortMapKey(mapMotherboards) {
		motherboard := mapMotherboards[key]

		write(1, fmt.Sprintf("//%s", key))
		write(1, fmt.Sprintf("class %s {", ToGoVariableName(motherboard.Name)))
		write(1, "public:")
		write(2, fmt.Sprintf("static constexpr const char* Name = \"%s\";", motherboard.Name))
		write(2, fmt.Sprintf("static constexpr const char* Adr = \"%s\";\n", motherboard.Adr))

		//

		bufStrPinout := make([][]string, 0)
		for _, pin := range sortMapKeyInt(motherboard.Esp32Pinout) {
			name := motherboard.Esp32Pinout[pin]
			bufStrPinout = append(bufStrPinout, []string{pin, name})
		}

		write(2, "typedef enum {")
		for _, pin := range bufStrPinout {
			write(3, fmt.Sprintf("%s_%s,\t//%s", nameEsp32Pinout, ToGoVariableName(pin[1]), pin[1]))
		}
		write(2, fmt.Sprintf("} %s_t;\n", nameEsp32Pinout))

		bufStrI2C := make([][]string, 0)
		for adr, i2c := range motherboard.I2C {
			bufStrI2C = append(bufStrI2C, []string{fmt.Sprintf("%#02x", adr), i2c.Name, i2c.Chip})
		}
		write(2, "typedef enum {")
		for _, pin := range bufStrI2C {
			write(3, fmt.Sprintf("%s_%s,\t//%s", nameI2C, ToGoVariableName(pin[1]), pin[1]))
		}
		write(2, fmt.Sprintf("} %s_t;\n", nameI2C))

		write(2, fmt.Sprintf("static std::map<%s_t, %s*> pinout;", nameEsp32Pinout, nameStructEsp32Pinout))
		write(2, fmt.Sprintf("static std::map<%s_t, %s*> i2c;", nameI2C, nameStructMotherboardI2C))
		write(2, fmt.Sprintf("static std::map<unsigned char, %s_t> i2cAdr;", nameI2C))
		write(1, "};\n")

		write(1, "/"+strings.Repeat("/", 8)+"/\n")

		// //

		writeBuf := make([]string, 0)
		for _, pin := range bufStrPinout {
			hashName := "_P" + strings.ToUpper(Hash(nameEsp32Pinout+pin[0]+pin[1]+key))

			write(1, fmt.Sprintf("static %s %s = { %s, \"%s\" };",
				nameStructEsp32Pinout, hashName, pin[0], pin[1],
			))
			writeBuf = append(writeBuf, fmt.Sprintf("{ %s::%s_%s, &%s },",
				ToGoVariableName(motherboard.Name), nameEsp32Pinout, ToGoVariableName(pin[1]), hashName,
			))
		}

		write(1, fmt.Sprintf("std::map<%s::%s_t, %s*> %s::pinout = {",
			ToGoVariableName(motherboard.Name), nameEsp32Pinout, nameStructEsp32Pinout, ToGoVariableName(motherboard.Name),
		))
		for _, text := range writeBuf {
			write(2, text)
		}
		write(1, "};\n")

		// //

		writeBuf = make([]string, 0)
		writeBuf2 := make([]string, 0)
		for _, i2c := range bufStrI2C {
			hashName := "_I" + strings.ToUpper(Hash(nameStructMotherboardI2C+i2c[0]+i2c[1]+i2c[2]+key))

			write(1, fmt.Sprintf("static %s %s = { \"%s\", \"%s\", %s };",
				nameStructMotherboardI2C, hashName, i2c[1], i2c[2], i2c[0],
			))
			writeBuf = append(writeBuf, fmt.Sprintf("{ %s::%s_%s, &%s },",
				ToGoVariableName(motherboard.Name), nameI2C, ToGoVariableName(i2c[1]), hashName,
			))
			writeBuf2 = append(writeBuf2, fmt.Sprintf("{ %s, %s::%s_%s },",
				i2c[0], ToGoVariableName(motherboard.Name), nameI2C, ToGoVariableName(i2c[1]),
			))
		}

		write(1, fmt.Sprintf("std::map<%s::%s_t, %s*> %s::i2c = {",
			ToGoVariableName(motherboard.Name), nameI2C, nameStructMotherboardI2C, ToGoVariableName(motherboard.Name),
		))
		for _, text := range writeBuf {
			write(2, text)
		}
		write(1, "};")

		write(1, fmt.Sprintf("std::map<unsigned char, %s::%s_t> %s::i2cAdr = {",
			ToGoVariableName(motherboard.Name), nameI2C, ToGoVariableName(motherboard.Name),
		))
		for _, text := range writeBuf2 {
			write(2, text)
		}
		write(1, "};\n")

		// ////////

		write(1, "/"+strings.Repeat("**", 16)+"/\n")
	}
}

func writeCppModules(mapModules map[string]ModulObj, file *os.File) {
	write := func(tab uint8, text string) {
		writeCpp_write(file, tab, text)
	}

	// //

	write(1, "class Modules {")
	write(1, "public:")
	write(2, "static const int _lenAdr = 4;")
	write(2, "")

	write(2, "struct arr_v;")
	write(2, "struct byte_v {unsigned char data;byte_v() : data(0) {};explicit byte_v(unsigned char val) : data(val) {};arr_v arr_();std::vector<bool> arr();const char* c_str();};")
	write(2, "struct arr_v {std::vector<bool> data;arr_v() : data(_lenAdr, false) {};explicit arr_v(const std::vector<bool>& v) : data(v) {};byte_v byte_();unsigned char byte();const char* c_str();};")
	write(2, "")

	// //

	devs := make([]string, 0)
	pinout := make(map[string][]string, 0)
	for _, key := range sortMapKey(mapModules) {
		modul := mapModules[key]
		devs = append(devs, modul.Name)

		for socket, _ := range modul.I2C {
			pinout[socket] = make([]string, 0)
		}
	}
	sort.Strings(devs)

	write(2, "typedef enum {")
	for _, name := range devs {
		write(3, fmt.Sprintf("M_%s,\t//%s", ToGoVariableName(name), name))
	}
	write(2, "} devises_t;\n")

	write(2, "struct I2cObj{")
	for _, key := range sortMapKey(pinout) {
		write(3, fmt.Sprintf("unsigned char %s;", ToGoVariableName(key)))
	}
	write(2, "};\n")

	write(2, "struct DevObj{devises_t Dev;byte_v Adr;const char* Chip;const char* Name;I2cObj I2C;std::map<const char*, const char*> Pinout;};")
	write(2, "")

	// //

	write(2, "static std::map<devises_t, DevObj> dev;")
	write(2, "static std::map<unsigned char, devises_t> adr;")
	write(2, "")

	for _, key := range sortMapKey(pinout) {
		write(2, fmt.Sprintf("static std::map<byte_v, devises_t> %sAdr;", ToGoVariableName(key)))
	}

	// //

	write(1, "};\n")

	write(1, "/"+strings.Repeat("/", 8)+"/\n")

	write(1, "inline Modules::arr_v Modules::byte_v::arr_() {Modules::arr_v result;for (int i = 0; i < Modules::_lenAdr; i++) {bool bitIsSet = (data & (1 << i)) != 0;result.data[i] = bitIsSet;}return result;}")
	write(1, "inline Modules::byte_v Modules::arr_v::byte_() {Modules::byte_v result;result.data = 0;for (int i = 0; i < Modules::_lenAdr; i++) {if (data[i]) {result.data |= (1 << i);}}return result;}")
	write(1, "inline unsigned char Modules::arr_v::byte() {unsigned char result = 0;for (int i = 0; i < _lenAdr; i++) { if (data[i]) { result |= (1 << i); } }return result;}")
	write(1, "inline const char* Modules::byte_v::c_str() {static char arr[_lenAdr + 1];for (int i = 0; i < _lenAdr; i++) {arr[i] = (data & (1 << i)) ? '1' : '0';}arr[_lenAdr] = '\\0';return arr;}")
	write(1, "inline const char* Modules::arr_v::c_str() {static char arr[_lenAdr + 1];for (int i = 0; i < _lenAdr; i++){arr[i] = data[i] ? '1' : '0';}arr[_lenAdr] = '\\0';return arr;}")
	write(1, "")
	write(1, "inline bool operator<(const Modules::byte_v& lhs, const Modules::byte_v& rhs) {return lhs.data < rhs.data;}")
	write(1, "")

	write(1, "/"+strings.Repeat("/", 8)+"/\n")

	// //

	valuesBuf := make([]string, 0)
	for _, key := range sortMapKey(mapModules) {
		modul := mapModules[key]
		adrStr := make([]string, 0)
		for _, b := range modul.Adr {
			adrStr = append(adrStr, fmt.Sprintf("%v", b))
		}
		pinsStr := make([]string, 0)
		for pinName, pinDescription := range modul.Pinout {
			pinsStr = append(pinsStr, fmt.Sprintf("{\"%s\", \"%s\"}", pinName, pinDescription))
		}

		hashName := strings.ToUpper(Hash(modul.Name + modul.Chip + strings.Join(adrStr, "") + strings.Join(pinsStr, "")))
		valuesBuf = append(valuesBuf, hashName)

		i2cStr := make([]string, 0)
		for _, mapKey := range sortMapKey(pinout) {
			val, ok := modul.I2C[mapKey]
			if ok {
				i2cStr = append(i2cStr, fmt.Sprintf("%v", val))
				pinout[mapKey] = append(pinout[mapKey], hashName)
			} else {
				i2cStr = append(i2cStr, "0x0")
			}
		}

		write(1, fmt.Sprintf(`static Modules::DevObj _M%s = {Modules::M_%s,Modules::arr_v({ %s }).byte_(),"%s", "%s",Modules::I2cObj{%s},std::map<const char*, const char*>{%s},};`,
			hashName,
			ToGoVariableName(modul.Name),
			strings.Join(adrStr, ", "),
			modul.Chip,
			modul.Name,
			strings.Join(i2cStr, ", "),
			strings.Join(pinsStr, ", "),
		))
	}
	write(1, "")

	//

	write(1, "std::map<Modules::devises_t, Modules::DevObj> Modules::dev = {")
	for _, value := range valuesBuf {
		write(2, fmt.Sprintf("{ _M%s.Dev, _M%s },", value, value))
	}
	write(1, "};")

	write(1, "std::map<unsigned char, Modules::devises_t> Modules::adr = {")
	for _, key := range sortMapKey(mapModules) {
		modul := mapModules[key]
		for _, adr := range modul.I2C {
			write(2, fmt.Sprintf("{ %#02x, Modules::M_%s },", adr, ToGoVariableName(modul.Name)))
		}
	}
	write(1, "};")
	write(1, "")

	for _, pinoutName := range sortMapKey(pinout) {
		write(1, fmt.Sprintf("std::map<Modules::byte_v, Modules::devises_t> Modules::%sAdr = {", ToGoVariableName(pinoutName)))

		for _, hashName := range pinout[pinoutName] {
			write(2, fmt.Sprintf("{ _M%s.Adr, _M%s.Dev },", hashName, hashName))
		}
		write(1, "};")
	}
}

func writeCppDrivers(mapDrivers map[string]DriverObj, file *os.File) {
	write := func(tab uint8, text string) {
		writeCpp_write(file, tab, text)
	}

	// //

	write(1, "class Drivers {")
	write(1, "public:")
	write(2, "static const int _lenAdr = 3;")
	write(2, "")

	write(2, "struct arr_v;")
	write(2, "struct byte_v {unsigned char data;byte_v() : data(0) {};explicit byte_v(unsigned char val) : data(val) {};arr_v arr_();std::vector<bool> arr();const char* c_str();};")
	write(2, "struct arr_v {std::vector<bool> data;arr_v() : data(_lenAdr, false) {};explicit arr_v(const std::vector<bool>& v) : data(v) {};byte_v byte_();unsigned char byte();const char* c_str();};")
	write(2, "")

	//

	protocols := make(map[string]bool)
	devs := make(map[string][]bool, 0)
	for _, key := range sortMapKey(mapDrivers) {
		driver := mapDrivers[key]
		devs[driver.Name] = driver.Adr

		for _, namePr := range driver.Protocols {
			protocols[namePr] = true
		}
	}

	write(2, "typedef enum {")
	for _, name := range sortMapKey(devs) {
		write(3, fmt.Sprintf("D_%s,\t//%s", ToGoVariableName(name), name))
	}
	write(2, "} devises_t;\n")

	write(2, "typedef enum {")
	for _, text := range sortMapKey(protocols) {
		write(3, fmt.Sprintf("P_%s,\t//%s", ToGoVariableName(text), text))
	}
	write(2, "} protocols_t;\n")

	//

	write(2, "struct DevObj{devises_t Dev;byte_v Adr;const char* Name;std::vector<protocols_t> Protocols;};")
	write(2, "")
	write(2, "static std::map<devises_t, DevObj> dev;")
	write(2, "static std::map<byte_v, devises_t> adr;")
	write(1, "};\n")

	write(1, "/"+strings.Repeat("/", 8)+"/\n")

	write(1, "inline Drivers::arr_v Drivers::byte_v::arr_() {Drivers::arr_v result;for (int i = 0; i < Drivers::_lenAdr; i++) {bool bitIsSet = (data & (1 << i)) != 0;result.data[i] = bitIsSet;}return result;}")
	write(1, "inline Drivers::byte_v Drivers::arr_v::byte_() {Drivers::byte_v result;result.data = 0;for (int i = 0; i < Drivers::_lenAdr; i++) {if (data[i]) {result.data |= (1 << i);}}return result;}")
	write(1, "inline std::vector<bool> Drivers::byte_v::arr() {std::vector<bool> vec(_lenAdr, false);for (int i = 0; i < _lenAdr; i++) { vec[i] = (data & (1 << i)) != 0; }return vec;}")
	write(1, "inline unsigned char Drivers::arr_v::byte() {unsigned char result = 0;for (int i = 0; i < _lenAdr; i++) { if (data[i]) { result |= (1 << i); } }return result;}")
	write(1, "inline const char* Drivers::byte_v::c_str() {static char arr[_lenAdr + 1];for (int i = 0; i < _lenAdr; i++) {arr[i] = (data & (1 << i)) ? '1' : '0';}arr[_lenAdr] = '\\0';return arr;}")
	write(1, "inline const char* Drivers::arr_v::c_str() {static char arr[_lenAdr + 1];for (int i = 0; i < _lenAdr; i++){arr[i] = data[i] ? '1' : '0';}arr[_lenAdr] = '\\0';return arr;}")
	write(1, "")
	write(1, "inline bool operator<(const Drivers::byte_v& lhs, const Drivers::byte_v& rhs) {return lhs.data < rhs.data;}")
	write(1, "")
	write(1, "/"+strings.Repeat("/", 8)+"/\n")

	//

	valueArr := make([]string, 0)
	for _, key := range sortMapKey(mapDrivers) {
		driver := mapDrivers[key]
		protocolStr := make([]string, 0)
		for _, namePr := range driver.Protocols {
			protocolStr = append(protocolStr, fmt.Sprintf("Drivers::P_%s", ToGoVariableName(namePr)))
		}
		adrStr := make([]string, 0)
		for _, b := range driver.Adr {
			adrStr = append(adrStr, fmt.Sprintf("%v", b))
		}

		hashName := strings.ToUpper(Hash(key + driver.Name + strings.Join(protocolStr, "") + strings.Join(adrStr, "")))
		valueArr = append(valueArr, hashName)

		write(1, fmt.Sprintf("static Drivers::DevObj _D%s = {Drivers::D_%s, Drivers::arr_v({ %s }).byte_(), \"%s\", { %s }};",
			hashName,
			ToGoVariableName(driver.Name),
			strings.Join(adrStr, ", "),
			driver.Name,
			strings.Join(protocolStr, ", "),
		))
	}
	write(1, "")

	write(1, "std::map<Drivers::byte_v, Drivers::devises_t> Drivers::adr = {")
	for _, hashName := range valueArr {
		write(2, fmt.Sprintf("{ _D%s.Adr, _D%s.Dev },", hashName, hashName))
	}
	write(1, "};")

	write(1, "std::map<Drivers::devises_t, Drivers::DevObj> Drivers::dev = {")
	for _, hashName := range valueArr {
		write(2, fmt.Sprintf("{ _D%s.Dev, _D%s },", hashName, hashName))
	}
	write(1, "};")
}

// //

func writeCpp(obj *IronAdressbookObj, pathToFile string) error {
	rootFileName := path.Base(pathToFile)
	rootDir := filepath.Dir(pathToFile)

	// //

	filesDir := filepath.Join(rootDir, "addressbook")
	if err := os.Mkdir(filesDir, 0755); err != nil {
		return err
	}
	writeCpp_delInDir(filesDir)

	// // // //

	fileRoot, err := writeCpp_FileBegin(rootFileName, rootDir)
	if err != nil {
		return err
	}
	defer writeCpp_FileEnd(fileRoot)

	fileMotherboard, err := writeCpp_FileBegin("motherboards.h", filesDir)
	if err != nil {
		return err
	}
	defer writeCpp_FileEnd(fileMotherboard)

	fileModules, err := writeCpp_FileBegin("modules.h", filesDir)
	if err != nil {
		return err
	}
	defer writeCpp_FileEnd(fileModules)

	fileDrivers, err := writeCpp_FileBegin("drivers.h", filesDir)
	if err != nil {
		return err
	}
	defer writeCpp_FileEnd(fileDrivers)

	// // // //

	mapMotherboards, mapModules, mapDrivers := genMaps(obj)

	writeCppMotherboards(mapMotherboards, fileMotherboard)
	writeCppModules(mapModules, fileModules)
	writeCppDrivers(mapDrivers, fileDrivers)

	// // // //

	writeCpp_write(fileRoot, 1, "#include <map>")
	writeCpp_write(fileRoot, 1, "#include <vector>")
	writeCpp_write(fileRoot, 1, "")

	writeCpp_write(fileRoot, 1, fmt.Sprintf("#include \"addressbook/%s\"", path.Base(fileMotherboard.Name())))
	writeCpp_write(fileRoot, 1, fmt.Sprintf("#include \"addressbook/%s\"", path.Base(fileModules.Name())))
	writeCpp_write(fileRoot, 1, fmt.Sprintf("#include \"addressbook/%s\"", path.Base(fileDrivers.Name())))

	if err == nil {
		fmt.Printf("The file was created successfully. \n\tDir: %s \n\tFile: %s\n", cyan(filepath.Dir(pathToFile)), green(filepath.Base(pathToFile)))
	}
	return err
}

// //////////////

func init() {
	writeCppCmd.Flags().StringVar(&CmdFromFilePath, "fileFrom", "", "Path to the file")
	writeCppCmd.Flags().StringVar(&CmdToFilePath, "fileTo", "", "Path to the root file around which structures will be generated. The file itself will contain C++ code with #include. You can specify a directory.")

	rootCmd.AddCommand(writeCppCmd)
}
