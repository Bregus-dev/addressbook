package main

import (
	"errors"
	"fmt"
	"github.com/spf13/cobra"
	"os"
	"path"
	"path/filepath"
	"sort"
	"strings"
)

// //////////////////////////////////////////////////////////////

var writeCppCmd = &cobra.Command{
	Use:   "write-cpp",
	Short: "C++ file generation",
	RunE: func(cmd *cobra.Command, args []string) error {
		if CmdFromFilePath == "" {
			return errors.New("you must specify a file using " + cyan("--fileFrom"))
		}

		pathFileRead := CheckFilePath(CmdFromFilePath)
		if pathFileRead != FilePathValid {
			return errors.New(cyan("--fileFrom") + ":\t" + pathFileRead.String())
		}

		CmdFromFilePath, err := filepath.Abs(CmdFromFilePath)
		if err != nil {
			return errors.New(cyan("--fileFrom") + ":\t" + err.Error())
		}

		//

		if CmdToFilePath == "" {
			return errors.New("you must specify a file using " + cyan("--fileTo"))
		}

		pathFileWrite := CheckFilePath(CmdToFilePath)
		if pathFileWrite != FilePathValid && pathFileWrite != FilePathIsDir && pathFileWrite != FilePathValidDir {
			return errors.New(cyan("--fileTo") + ":\t" + pathFileWrite.String())
		}

		CmdToFilePath, err := filepath.Abs(CmdToFilePath)
		if err != nil {
			return errors.New(cyan("--fileTo") + ":\t" + err.Error())
		}

		//

		if pathFileWrite == FilePathIsDir {
			CmdToFilePath = filepath.Join(CmdToFilePath, "addressbook.h")
		}

		//

		obj, err := ParseYml(CmdFromFilePath)
		if err != nil {
			return err
		}

		return writeCpp(obj, CmdToFilePath)
	},
}

// //

func writeCpp_FileBegin(fileName, pathToDir string) (*os.File, error) {
	file, err := os.Create(path.Join(pathToDir, fileName))
	if err != nil {
		return nil, err
	}

	fileName = strings.ToUpper(ToGoVariableName(fileName))

	_, err = file.WriteString("/**  This file is automatically generated  **/\n\n")
	if err != nil {
		return nil, err
	}
	file.WriteString(fmt.Sprintf("#ifndef %s_H\n#define %s_H\n\n", fileName, fileName))

	return file, nil
}

func writeCpp_delInDir(dir string) {
	entries, err := os.ReadDir(dir)
	if err != nil {
		return
	}

	for _, entry := range entries {
		if !entry.IsDir() {
			os.Remove(filepath.Join(dir, entry.Name()))
		}
	}
}

func writeCpp_FileEnd(file *os.File) {
	file.WriteString("\n#endif")
	file.Close()
}

func writeCpp_write(file *os.File, tab uint8, text string) {
	file.WriteString(strings.Repeat("\t", int(tab)))
	file.WriteString(text)
	file.WriteString("\n")
}

//

func writeCppMotherboards(mapMotherboards map[string]MotherboardObj, file *os.File) {
	write := func(tab uint8, text string) {
		writeCpp_write(file, tab, text)
	}

	// //

	write(1, "class Motherboards {")
	write(1, "public:")
	write(2, "")

	// //

	devs := make([]string, 0)
	i2cMap := make(map[byte][]string)
	for _, key := range sortMapKey(mapMotherboards) {
		motherboard := mapMotherboards[key]

		devs = append(devs, motherboard.Name)
		for adr := range motherboard.I2C {
			_, ok := i2cMap[adr]
			if !ok {
				i2cMap[adr] = make([]string, 0)
			}
			i2cMap[adr] = append(i2cMap[adr], ToGoVariableName(motherboard.Name))
		}
	}

	write(2, "typedef enum {")
	for _, name := range devs {
		write(3, fmt.Sprintf("MB_%s,\t//%s", ToGoVariableName(name), name))
	}
	write(2, "} devises_t;\n")

	write(2, "struct DevObj{devises_t Dev;const char* Name;std::map<const char*, unsigned char> Pinout;std::map<const char*, unsigned char> I2C;};\n")

	write(2, "static std::map<devises_t, DevObj> dev;")
	write(2, "static std::map<unsigned char, std::vector<devises_t>> i2c;")
	write(1, "};\n")

	write(1, "/"+strings.Repeat("/", 8)+"/\n")

	// //

	hashBuf := make([][]string, 0)
	for _, key := range sortMapKey(mapMotherboards) {
		motherboard := mapMotherboards[key]
		pinoutStr := make([]string, 0)
		i2cStr := make([]string, 0)

		for adr, i2c := range motherboard.I2C {
			i2cStr = append(i2cStr, fmt.Sprintf("{\"%s\", %#02x}", i2c.Name, adr))
		}
		sort.Strings(i2cStr)

		for _, pin := range sortMapKey(motherboard.Esp32Pinout) {
			pinoutStr = append(pinoutStr, fmt.Sprintf("{\"%s\", %s}", motherboard.Esp32Pinout[pin], pin))
		}

		hashName := strings.ToUpper(Hash(motherboard.Name + strings.Join(pinoutStr, "") + strings.Join(i2cStr, "")))
		hashBuf = append(hashBuf, []string{ToGoVariableName(motherboard.Name), hashName})

		write(1, fmt.Sprintf("static Motherboards::DevObj _MB%s = {", hashName))
		write(2, fmt.Sprintf("Motherboards::MB_%s,", ToGoVariableName(motherboard.Name)))
		write(2, fmt.Sprintf("\"%s\",", motherboard.Name))

		write(2, fmt.Sprintf("std::map<const char*, unsigned char>{"))
		for _, txt := range pinoutStr {
			write(3, txt+",")
		}
		write(2, fmt.Sprintf("},"))

		write(2, fmt.Sprintf("std::map<const char*, unsigned char>{"))
		for _, txt := range i2cStr {
			write(3, txt+",")
		}
		write(2, fmt.Sprintf("},"))

		write(1, fmt.Sprintf("};"))
	}
	write(1, "")

	write(1, "std::map<Motherboards::devises_t, Motherboards::DevObj> Motherboards::dev = {")
	for _, arr := range hashBuf {
		write(2, fmt.Sprintf("{Motherboards::MB_%s, _MB%s},", arr[0], arr[1]))
	}
	write(1, "};\n")

	write(1, "std::map<unsigned char, std::vector<Motherboards::devises_t>> Motherboards::i2c = {")
	for key, arrName := range i2cMap {
		bufArr := make([]string, 0)
		for _, name := range arrName {
			bufArr = append(bufArr, fmt.Sprintf("Motherboards::MB_%s", ToGoVariableName(name)))
		}

		write(2, fmt.Sprintf(
			"{%#2x, std::vector<Motherboards::devises_t>{%s}},",
			key,
			strings.Join(bufArr, ", "),
		))
	}
	write(1, "};\n")
}

func writeCppModules(mapModules map[string]ModulObj, file *os.File) {
	write := func(tab uint8, text string) {
		writeCpp_write(file, tab, text)
	}

	// //

	write(1, "class Modules {")
	write(1, "public:")
	write(2, "static const int _lenAdr = 4;")
	write(2, "")

	write(2, "struct arr_v;")
	write(2, "struct byte_v {unsigned char data;byte_v() : data(0) {};explicit byte_v(unsigned char val) : data(val) {};arr_v arr_();std::vector<bool> arr();const char* c_str();};")
	write(2, "struct arr_v {std::vector<bool> data;arr_v() : data(_lenAdr, false) {};explicit arr_v(const std::vector<bool>& v) : data(v) {};byte_v byte_();unsigned char byte();const char* c_str();};")
	write(2, "")

	// //

	devs := make([]string, 0)
	pinout := make(map[string][]string, 0)
	for _, key := range sortMapKey(mapModules) {
		modul := mapModules[key]
		devs = append(devs, modul.Name)

		for socket, _ := range modul.I2C {
			pinout[socket] = make([]string, 0)
		}
	}
	sort.Strings(devs)

	write(2, "typedef enum {")
	for _, name := range devs {
		write(3, fmt.Sprintf("M_%s,\t//%s", ToGoVariableName(name), name))
	}
	write(2, "} devises_t;\n")

	write(2, "struct I2cObj{")
	for _, key := range sortMapKey(pinout) {
		write(3, fmt.Sprintf("unsigned char %s;", ToGoVariableName(key)))
	}
	write(2, "};\n")

	write(2, "struct DevObj{devises_t Dev;byte_v Adr;const char* Chip;const char* Name;I2cObj I2C;std::map<const char*, const char*> Pinout;};")
	write(2, "")

	// //

	write(2, "static std::map<devises_t, DevObj> dev;")
	write(2, "static std::map<unsigned char, devises_t> adr;")
	write(2, "")

	for _, key := range sortMapKey(pinout) {
		write(2, fmt.Sprintf("static std::map<byte_v, devises_t> %sAdr;", ToGoVariableName(key)))
	}

	// //

	write(1, "};\n")

	write(1, "/"+strings.Repeat("/", 8)+"/\n")

	write(1, "inline Modules::arr_v Modules::byte_v::arr_() {Modules::arr_v result;for (int i = 0; i < Modules::_lenAdr; i++) {bool bitIsSet = (data & (1 << i)) != 0;result.data[i] = bitIsSet;}return result;}")
	write(1, "inline Modules::byte_v Modules::arr_v::byte_() {Modules::byte_v result;result.data = 0;for (int i = 0; i < Modules::_lenAdr; i++) {if (data[i]) {result.data |= (1 << i);}}return result;}")
	write(1, "inline unsigned char Modules::arr_v::byte() {unsigned char result = 0;for (int i = 0; i < _lenAdr; i++) { if (data[i]) { result |= (1 << i); } }return result;}")
	write(1, "inline const char* Modules::byte_v::c_str() {static char arr[_lenAdr + 1];for (int i = 0; i < _lenAdr; i++) {arr[i] = (data & (1 << i)) ? '1' : '0';}arr[_lenAdr] = '\\0';return arr;}")
	write(1, "inline const char* Modules::arr_v::c_str() {static char arr[_lenAdr + 1];for (int i = 0; i < _lenAdr; i++){arr[i] = data[i] ? '1' : '0';}arr[_lenAdr] = '\\0';return arr;}")
	write(1, "")
	write(1, "inline bool operator<(const Modules::byte_v& lhs, const Modules::byte_v& rhs) {return lhs.data < rhs.data;}")
	write(1, "")

	write(1, "/"+strings.Repeat("/", 8)+"/\n")

	// //

	valuesBuf := make([]string, 0)
	for _, key := range sortMapKey(mapModules) {
		modul := mapModules[key]
		adrStr := make([]string, 0)
		for _, b := range modul.Adr {
			adrStr = append(adrStr, fmt.Sprintf("%v", b))
		}
		pinsStr := make([]string, 0)
		for pinName, pinDescription := range modul.Pinout {
			pinsStr = append(pinsStr, fmt.Sprintf("{\"%s\", \"%s\"}", pinName, pinDescription))
		}

		hashName := strings.ToUpper(Hash(modul.Name + modul.Chip + strings.Join(adrStr, "") + strings.Join(pinsStr, "")))
		valuesBuf = append(valuesBuf, hashName)

		i2cStr := make([]string, 0)
		for _, mapKey := range sortMapKey(pinout) {
			val, ok := modul.I2C[mapKey]
			if ok {
				i2cStr = append(i2cStr, fmt.Sprintf("%v", val))
				pinout[mapKey] = append(pinout[mapKey], hashName)
			} else {
				i2cStr = append(i2cStr, "0x0")
			}
		}

		write(1, fmt.Sprintf(`static Modules::DevObj _M%s = {Modules::M_%s,Modules::arr_v({ %s }).byte_(),"%s", "%s",Modules::I2cObj{%s},std::map<const char*, const char*>{%s},};`,
			hashName,
			ToGoVariableName(modul.Name),
			strings.Join(adrStr, ", "),
			modul.Chip,
			modul.Name,
			strings.Join(i2cStr, ", "),
			strings.Join(pinsStr, ", "),
		))
	}
	write(1, "")

	//

	write(1, "std::map<Modules::devises_t, Modules::DevObj> Modules::dev = {")
	for _, value := range valuesBuf {
		write(2, fmt.Sprintf("{ _M%s.Dev, _M%s },", value, value))
	}
	write(1, "};")

	write(1, "std::map<unsigned char, Modules::devises_t> Modules::adr = {")
	for _, key := range sortMapKey(mapModules) {
		modul := mapModules[key]
		for _, adr := range modul.I2C {
			write(2, fmt.Sprintf("{ %#02x, Modules::M_%s },", adr, ToGoVariableName(modul.Name)))
		}
	}
	write(1, "};")
	write(1, "")

	for _, pinoutName := range sortMapKey(pinout) {
		write(1, fmt.Sprintf("std::map<Modules::byte_v, Modules::devises_t> Modules::%sAdr = {", ToGoVariableName(pinoutName)))

		for _, hashName := range pinout[pinoutName] {
			write(2, fmt.Sprintf("{ _M%s.Adr, _M%s.Dev },", hashName, hashName))
		}
		write(1, "};")
	}
}

func writeCppDrivers(mapDrivers map[string]DriverObj, file *os.File) {
	write := func(tab uint8, text string) {
		writeCpp_write(file, tab, text)
	}

	// //

	write(1, "class Drivers {")
	write(1, "public:")
	write(2, "static const int _lenAdr = 3;")
	write(2, "")

	write(2, "struct arr_v;")
	write(2, "struct byte_v {unsigned char data;byte_v() : data(0) {};explicit byte_v(unsigned char val) : data(val) {};arr_v arr_();std::vector<bool> arr();const char* c_str();};")
	write(2, "struct arr_v {std::vector<bool> data;arr_v() : data(_lenAdr, false) {};explicit arr_v(const std::vector<bool>& v) : data(v) {};byte_v byte_();unsigned char byte();const char* c_str();};")
	write(2, "")

	//

	protocols := make(map[string]bool)
	devs := make(map[string][]bool, 0)
	for _, key := range sortMapKey(mapDrivers) {
		driver := mapDrivers[key]
		devs[driver.Name] = driver.Adr

		for _, namePr := range driver.Protocols {
			protocols[namePr] = true
		}
	}

	write(2, "typedef enum {")
	for _, name := range sortMapKey(devs) {
		write(3, fmt.Sprintf("D_%s,\t//%s", ToGoVariableName(name), name))
	}
	write(2, "} devises_t;\n")

	write(2, "typedef enum {")
	for _, text := range sortMapKey(protocols) {
		write(3, fmt.Sprintf("P_%s,\t//%s", ToGoVariableName(text), text))
	}
	write(2, "} protocols_t;\n")

	//

	write(2, "struct DevObj{devises_t Dev;byte_v Adr;const char* Name;std::vector<protocols_t> Protocols;};")
	write(2, "")
	write(2, "static std::map<devises_t, DevObj> dev;")
	write(2, "static std::map<byte_v, devises_t> adr;")
	write(1, "};\n")

	write(1, "/"+strings.Repeat("/", 8)+"/\n")

	write(1, "inline Drivers::arr_v Drivers::byte_v::arr_() {Drivers::arr_v result;for (int i = 0; i < Drivers::_lenAdr; i++) {bool bitIsSet = (data & (1 << i)) != 0;result.data[i] = bitIsSet;}return result;}")
	write(1, "inline Drivers::byte_v Drivers::arr_v::byte_() {Drivers::byte_v result;result.data = 0;for (int i = 0; i < Drivers::_lenAdr; i++) {if (data[i]) {result.data |= (1 << i);}}return result;}")
	write(1, "inline std::vector<bool> Drivers::byte_v::arr() {std::vector<bool> vec(_lenAdr, false);for (int i = 0; i < _lenAdr; i++) { vec[i] = (data & (1 << i)) != 0; }return vec;}")
	write(1, "inline unsigned char Drivers::arr_v::byte() {unsigned char result = 0;for (int i = 0; i < _lenAdr; i++) { if (data[i]) { result |= (1 << i); } }return result;}")
	write(1, "inline const char* Drivers::byte_v::c_str() {static char arr[_lenAdr + 1];for (int i = 0; i < _lenAdr; i++) {arr[i] = (data & (1 << i)) ? '1' : '0';}arr[_lenAdr] = '\\0';return arr;}")
	write(1, "inline const char* Drivers::arr_v::c_str() {static char arr[_lenAdr + 1];for (int i = 0; i < _lenAdr; i++){arr[i] = data[i] ? '1' : '0';}arr[_lenAdr] = '\\0';return arr;}")
	write(1, "")
	write(1, "inline bool operator<(const Drivers::byte_v& lhs, const Drivers::byte_v& rhs) {return lhs.data < rhs.data;}")
	write(1, "")
	write(1, "/"+strings.Repeat("/", 8)+"/\n")

	//

	valueArr := make([]string, 0)
	for _, key := range sortMapKey(mapDrivers) {
		driver := mapDrivers[key]
		protocolStr := make([]string, 0)
		for _, namePr := range driver.Protocols {
			protocolStr = append(protocolStr, fmt.Sprintf("Drivers::P_%s", ToGoVariableName(namePr)))
		}
		adrStr := make([]string, 0)
		for _, b := range driver.Adr {
			adrStr = append(adrStr, fmt.Sprintf("%v", b))
		}

		hashName := strings.ToUpper(Hash(key + driver.Name + strings.Join(protocolStr, "") + strings.Join(adrStr, "")))
		valueArr = append(valueArr, hashName)

		write(1, fmt.Sprintf("static Drivers::DevObj _D%s = {Drivers::D_%s, Drivers::arr_v({ %s }).byte_(), \"%s\", { %s }};",
			hashName,
			ToGoVariableName(driver.Name),
			strings.Join(adrStr, ", "),
			driver.Name,
			strings.Join(protocolStr, ", "),
		))
	}
	write(1, "")

	write(1, "std::map<Drivers::byte_v, Drivers::devises_t> Drivers::adr = {")
	for _, hashName := range valueArr {
		write(2, fmt.Sprintf("{ _D%s.Adr, _D%s.Dev },", hashName, hashName))
	}
	write(1, "};")

	write(1, "std::map<Drivers::devises_t, Drivers::DevObj> Drivers::dev = {")
	for _, hashName := range valueArr {
		write(2, fmt.Sprintf("{ _D%s.Dev, _D%s },", hashName, hashName))
	}
	write(1, "};")
}

// //

func writeCpp(obj *IronAdressbookObj, pathToFile string) error {
	rootFileName := path.Base(pathToFile)
	rootDir := filepath.Dir(pathToFile)

	// //

	filesDir := filepath.Join(rootDir, "addressbook")
	os.Mkdir(filesDir, 0755)
	writeCpp_delInDir(filesDir)

	// // // //

	fileRoot, err := writeCpp_FileBegin(rootFileName, rootDir)
	if err != nil {
		return err
	}
	defer writeCpp_FileEnd(fileRoot)

	fileMotherboard, err := writeCpp_FileBegin("motherboards.h", filesDir)
	if err != nil {
		return err
	}
	defer writeCpp_FileEnd(fileMotherboard)

	fileModules, err := writeCpp_FileBegin("modules.h", filesDir)
	if err != nil {
		return err
	}
	defer writeCpp_FileEnd(fileModules)

	fileDrivers, err := writeCpp_FileBegin("drivers.h", filesDir)
	if err != nil {
		return err
	}
	defer writeCpp_FileEnd(fileDrivers)

	// // // //

	mapMotherboards, mapModules, mapDrivers := genMaps(obj)

	writeCppMotherboards(mapMotherboards, fileMotherboard)
	writeCppModules(mapModules, fileModules)
	writeCppDrivers(mapDrivers, fileDrivers)

	// // // //

	writeCpp_write(fileRoot, 1, "#include <map>")
	writeCpp_write(fileRoot, 1, "#include <vector>")
	writeCpp_write(fileRoot, 1, "")

	writeCpp_write(fileRoot, 1, fmt.Sprintf("#include \"addressbook/%s\"", path.Base(fileMotherboard.Name())))
	writeCpp_write(fileRoot, 1, fmt.Sprintf("#include \"addressbook/%s\"", path.Base(fileModules.Name())))
	writeCpp_write(fileRoot, 1, fmt.Sprintf("#include \"addressbook/%s\"", path.Base(fileDrivers.Name())))

	if err == nil {
		fmt.Printf("The file was created successfully. \n\tDir: %s \n\tFile: %s\n", cyan(filepath.Dir(pathToFile)), green(filepath.Base(pathToFile)))
	}
	return err
}

// //////////////

func init() {
	writeCppCmd.Flags().StringVar(&CmdFromFilePath, "fileFrom", "", "Path to the file")
	writeCppCmd.Flags().StringVar(&CmdToFilePath, "fileTo", "", "Path to the root file around which structures will be generated. The file itself will contain C++ code with #include. You can specify a directory.")

	rootCmd.AddCommand(writeCppCmd)
}
